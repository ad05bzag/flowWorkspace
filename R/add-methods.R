setMethod("add",
		signature=c(wf="GatingSet", "list"),
		definition=function(wf, action, ...)
		{
			
			flist<-filterList(action)
			add(wf,flist,...)
			
		})
setMethod("add",
		signature=c("GatingSetInternal", "filterList"),
		definition=function(wf, action, ...)
		{
			samples<-getSamples(wf)
			
			if(!setequal(names(action),samples))
				stop("names of filterList do not match with the sample names in the gating set!")			
			
			nodeIDs<-lapply(samples,function(sample){
								curFilter<-action[[sample]]
								gh<-wf[[sample]]
#								browser()
								add(wf=gh,action=curFilter,...)
							})
					
			nodeID<-nodeIDs[[1]]
		
		if(!all(sapply(nodeIDs[-1],function(x)identical(x,nodeID))))
			stop("nodeID are not identical across samples!")
		
		nodeID
			
		})
    
setMethod("add",
		signature=c("GatingSetInternal", "filter"),
		definition=function(wf, action, ...)
		{
			
			message("replicating filter '",identifier(action),"' across samples!")
			
			actions<-sapply(getSamples(wf),function(x)return(action))
			add(wf,actions,...)
			
		})
.addGate<-function(gh,filterObject,parent=NULL, name=NULL,negated=FALSE){
#  browser()
	if(is.null(name))
		name<-filterObject$filterId
    #replace the slash with colon 
    #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
    
#	browser()
	##get node ID
	nodes<-getNodes(gh)
	if(is.null(parent))
		pid<-1
	else
	{
		if(is.numeric(parent))
			pid<-parent
		else
			pid<-.getNodeInd(gh,parent)
	}
	filterObject$negated<-negated
#	browser()	
	nodeID<-.Call("R_addGate",gh@pointer,getSample(gh),filterObject,as.integer(pid-1),name)
	nodeID+1
}


setMethod("add",
		signature=c("GatingHierarchyInternal", "filter"),
		definition=function(wf, action,... )
		{
			
			.addGate(wf,filterObject(action),...)
		})


setMethod("add",
		signature=c("GatingHierarchyInternal", "quadGate"),
		definition=function(wf, action,names=NULL,... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			pd<-pData(parameters(getData(wf)))
			desc<-sapply(params,function(x)flowWorkspaceEx:::.getChannelMarker(pd,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							add(wf,rg,...)
						})
					)
			
			
			
		})
##TODO:Either to create a speical logicalGate derived from "filter"
## that just contains the logical vector as indices generated by other algrorithm 
## like flowClust..
## Or we could try to use filterResult and filterResultList from flowCore
## to save the efforts of adding new filter type, but the extra contructor is necessary to 
## convert logical vector to filterResult.
#setMethod("add",
#		signature=c("GatingHierarchyInternal", "logicalGate"),
#		definition=function(wf, action, name,...)
#		{
#			
#			
##			browser()
#			if(missing(name))
#				stop("population name is required!")
#			if(length(action)!=nrow(getData(wf)))
#				stop("the length of logical vector is different from events number in: ",getSample(wf))
#			
#			
#			filterObject<-list(type=as.integer(6)
#								,indices=action
#								)	
#			
#			.addGate(wf,filterObject,...)
#		})

setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSetInternal",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
			invisible(lapply(envir,function(gh){
#								browser()
								Rm(symbol,gh,subSymbol,...)
							}))
		})

setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingHierarchyInternal",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
#			browser()
            
            nid<-.getNodeInd(envir,symbol)
			##remove all children nodes as well
			childrenNodeIds <- getChildren(envir,nid)
            #use path instead of unqiue name since the prefix of unique name
            #will change during deletion
            childrenPaths <- getNodes(envir, isPath = TRUE)[childrenNodeIds]
#            #strip the first slash
#            childrenPaths <- sapply(childrenPaths,function(thisPath)substr(thisPath,2,nchar(thisPath)),USE.NAMES=F)
			lapply(childrenPaths,function(child)Rm(child,envir))
			
            
            
			.Call("R_removeNode",envir@pointer,getSample(envir),nid-1)
		})

