#' @include filterObject-Methods.R
NULL


#' Create a GatingSet and add/remove the flowCore gate(or population) to/from a GatingHierarchy/GatingSet.
#' 
#' \code{GatingSet} method creates a gatingset from a flowSet with the ungated data as the root node.
#' \code{add} method add the flowCore gate to a GatingHierarchy/GatingSet.
#' \code{setGate} method update the gate of one population node in GatingHierarchy/GatingSet.
#' \code{Rm} method Remove the population node from a GatingHierarchy/GatingSet. 
#' They are equivalent to the \code{workFlow},\code{add} and \code{Rm} methods in \code{flowCore} package. 
#' \code{recompute} method does the actual gating after the gate is added,i.e. calculating the event indices according to the gate definition.   
#' @param wf A \code{GatingHierrarchy} or \code{GatingSet}
#' @param envir A \code{GatingHierrarchy} or \code{GatingSet}
#' @param action A \code{filter} or a list of \code{filter}s to be added to the  \code{GatingHierarchy} or \code{GatingSet}.
#' @param names  a \code{character} vector of length four,which specifies the population names resulted by adding a \code{quadGate}.
#' The order of the names is clock-wise starting from the top left quadrant population.
#' @param ... some other arguments to specify how the gates are added to the gating tree.
#' \itemize{
#'       \item parent: a \code{character} scalar to specify the parent node name where the new gate to be added to, by default it is NULL,which indicates the root node
#'       \item name: a \code{character} scalar to specify the node name of population that is generated by the gate to be added.
#'       The default value is NULL,then the name will be extracted from the filterId of the gate to be added 
#'       \item negated: a \code{logical} scalar to specify whether the gate is negated,which means the the population outside of the gate will be kept as the result population.
#'       It is FALSE by default. 
#'  }
#' @param symbol A \code{character} identifies the population node in a \code{GatingHierrarchy} or \code{GatingSet} to remove
#' @param subSymbol Not used.
#' @return 
#'   \code{GatingSet} method returns a \code{GatingSet} object with just root node.  
#'   \code{add} method returns a population node ID (or four population node IDs when adding a \code{quadGate}) that uniquely identify the population node within a  \code{GatingHierarchy}.
#' @seealso \code{\link{GatingSet-class}}
#' @examples
#' \dontrun{
#'     data(GvHD)
#' #select raw flow data
#'     fs<-GvHD[1:3]
#'     
#' #transform the raw data
#'     tf <- transformList(colnames(fs[[1]])[3:6], asinh, transformationId="asinh")
#'     fs_trans<-transform(fs,tf)
#'     
#' #add transformed data to a gatingset
#'     gs <- GatingSet(fs_trans)
#'     gs
#'     getNodes(gs[[1]]) #only contains root node
#'     
#' #add one gate
#'     rg <- rectangleGate("FSC-H"=c(200,400), "SSC-H"=c(250, 400),
#'         filterId="rectangle")
#'     
#'     nodeID<-add(gs, rg)#it is added to root node by default if parent is not specified
#'     nodeID
#'     getNodes(gs[[1]]) #the second population is named after filterId of the gate 
#'     
#' #add a quadGate
#'     qg <- quadGate("FL1-H"=2, "FL2-H"=4)
#'     nodeIDs<-add(gs,qg,parent="rectangle")
#'     nodeIDs #quadGate produces four population nodes
#'     getNodes(gs[[1]]) #population names are named after dimensions of gate if not specified
#'     
#' #add a boolean Gate
#'     bg<-booleanFilter(`CD15 FITC-CD45 PE+`|`CD15 FITC+CD45 PE-`)
#'     bg
#'     nodeID2<-add(gs,bg,parent="rectangle")
#'     nodeID2
#'     getNodes(gs[[1]])
#' #do the actual gating
#'     recompute(gs)
#'     
#' #plot one gate for one sample
#'     plotGate(gs[[1]],"rectangle")
#'     plotGate(gs[[1]],nodeIDs) #may be smoothed automatically if there are not enough events after gating
#'     
#' #plot gates across samples using lattice plot
#'     plotGate(gs,nodeID)
#' #plot all gates for one sample
#'     plotGate(gs[[1]])#boolean gate is skipped by default 
#'     plotGate(gs[[1]],bool=TRUE)
#'     
#' #plot the gating hierarchy
#'     require(Rgraphviz)
#'     plot(gs[[1]])
#' #remove one node causing the removal of all the descendants 
#'     Rm('rectangle', gs)
#'     getNodes(gs[[1]])
#'  }
#' @export 
#' @rdname add
#' @aliases
#' add
#' Rm
#' @importFrom flowCore add
setMethod("add",
		signature=c(wf="GatingSet", "list"),
		definition=function(wf, action, ...)
		{

            if(all(sapply(action, function(i)extends(class(i), "filterResult")))){
              #dispatch right away to avoid the overhead 
              #since filterResult is expensive to be passed around
              id <- selectMethod("add", signature = c("GatingSet", "filterList"))(wf, action, ...)
              return(id)
            }else if(all(sapply(action, function(i)extends(class(i), "filter"))))
			  flist <- filterList(action)
            else if(all(sapply(action, function(i)extends(class(i), "filters"))))
              flist <- filtersList(action)
            else
              stop ("the gate list doesn't constain valid 'filter', 'filters' or 'filterResult' objects!")
            
			add(wf,flist,...)
			
		})

#' @export 
#' @rdname add
setMethod("add",
    signature=c(wf="GatingSetList", "list"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="list"))(wf, action, ...)
      
    })    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSet", "filtersList"),
    definition=function(wf, action, ...)
    {
      selectMethod("add",signature = c(wf="GatingSet", action="filterList"))(wf, action, ...)
      
    })
    
#' @importClassesFrom flowCore filterList filtersList ellipsoidGate intersectFilter polygonGate rectangleGate filters
#' @importFrom flowCore filterList filtersList filters
#' @param validityCheck \code{logical} whether to check the consistency of tree structure across samples. default is TRUE. Can be turned off when speed is prefered to the robustness.
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingSet", "filterList"),
		definition=function(wf, action, validityCheck = TRUE,...)
		{
			samples<-sampleNames(wf)
			
			if(!setequal(names(action),samples))
				stop("names of gate list do not match with the sample names in the gating set!")			
			
			nodeIDs <- lapply(samples,function(sample){
								curFilter <- action[[sample]]
								gh <- wf[[sample]]
#								browser()
								add(wf = gh, action = curFilter, ...)
							})
					
			nodeID <- nodeIDs[[1]]
            
        if(validityCheck){
          if(!all(sapply(nodeIDs[-1],function(x)isTRUE(all.equal(x, nodeID, check.attributes = FALSE))))){
            #restore the gatingset by removing added nodes
            mapply(samples, nodeIDs, FUN = function(sample, nodeID){
                  gh <- wf[[sample]]
                  nodes <- getNodes(gh)[nodeID]
                  lapply(nodes, Rm, envir = gh)
                })
            stop("nodeID are not identical across samples!")
          }
          
        }
		nodeID
			
		})
    
#' @export 
#' @rdname add
setMethod("add",
        signature=c("GatingSetList", "filterList"),
        definition=function(wf, action, ...)
        {
          selectMethod("add",signature = c(wf="GatingSet", action="filterList"))(wf, action, ...)
        })
    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filtersList"),
    definition=function(wf, action, ...)
    {
      selectMethod("add",signature = c(wf="GatingSet", action="filtersList"))(wf, action, ...)
    })
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingSet", "filter"),
		definition=function(wf, action, ...)
		{
			
			message("replicating filter '",identifier(action),"' across samples!")
			
			actions<-sapply(sampleNames(wf),function(x)return(action))
			add(wf,actions,...)
			
		})
#' @export 
#' @rdname add    
setMethod("add",
    signature=c("GatingSet", "filters"),
    definition=function(wf, action, ...)
    {
      
      message("replicating filters '",identifier(action),"' across samples!")
      
      actions <- sapply(sampleNames(wf),function(x)return(action))
      add(wf,actions,...)
      
    })    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filter"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="filter"))(wf, action, ...)
      
    })
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingSetList", "filters"),
    definition=function(wf, action, ...)
    {
      
      selectMethod("add",signature = c(wf="GatingSet", action="filters"))(wf, action, ...)
      
    })

#' @param recompute \code{logical} whether to recompute the event indices right after gate is added. 
#'                                  Oftentimes it is more efficient to let user to determining how and when the flow data is loaded
#'                                  Thus default it FALSE.                      
.addGate <- function(gh, filterObject, parent = "root", name = NULL, negated = FALSE, recompute = FALSE){
  
	if(is.null(name))
		name <- filterObject$filterId
    #replace the slash with colon 
    #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
    
	
	
	filterObject$negated <- negated
#	browser()	
    sn <- sampleNames(gh)
    
    ptr <- gh@pointer
	nodeID <- .Call("R_addGate", ptr, sn, filterObject, parent, name)

    if(recompute){
      extend_val <- 0
      ignore_case <- FALSE
      gains <- NULL
      #this always load the raw data
      #which may not be optimal for bool gate
      data <- getData(gh)
      mat <- exprs(data)
      .Call("R_gating", ptr, mat,sn,gains,nodeID,recompute,extend_val, ignore_case, TRUE)
    }
        
	nodeID+1
}

#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingHierarchy", "filter"),
		definition=function(wf, action,... )
		{
			
			.addGate(wf,filterObject(action),...)
		})
    
#' @export 
#' @rdname add
setMethod("add",
    signature=c("GatingHierarchy", "filters"),
    definition=function(wf, action, names = NULL, ... )
    {
      if(!is.null(names))
      {
        if(any(duplicated(names)))
          stop("population names given by 'name` argument are not unqiue")
        if(length(names)!=length(action))
          stop("number of population names (given by 'name' argument) does not agree with the number of filter objects in 'filters'!")
        
        unlist(mapply(action, names, FUN = function(thisFilter, thisName){
                  add(wf,thisFilter, name = thisName, ...)
                })
        )
      }else
        unlist(lapply(action, function(thisFilter)add(wf, thisFilter,...)))
      
    })
#' @export 
#' @rdname add
setMethod("add",
		signature=c("GatingHierarchy", "quadGate"),
		definition=function(wf, action, names = NULL, ... )
		{
			
			#convert to four recgates			
			params<-parameters(action)
			fr <- getData(wf, use.exprs = FALSE)
			desc<-sapply(params,function(x)getChannelMarker(fr,x)$des)
			
			v <- action@boundary[params[1]]
			h <- action@boundary[params[2]]
			mat <- matrix(c(-Inf, v, h, Inf
							, v, Inf, h, Inf
							, v, Inf, -Inf, h
							, -Inf, v, -Inf,h
							)
						, byrow=TRUE
						, ncol=4)              
			#clock-wise from top left quadrant
			if(is.null(names))
				names <- matrix(c(sprintf("%s-%s+", desc[1], desc[2]),
									sprintf("%s+%s+", desc[1], desc[2]),
									sprintf("%s+%s-", desc[1], desc[2]),
									sprintf("%s-%s-", desc[1], desc[2])
									),
								ncol=2)
			if(length(unique(names))!=4)
				stop("names have to be four unique strings!")
			unlist(lapply(1:4,function(i){
#								browser()
							rg <- rectangleGate(.gate=matrix(mat[i,], ncol=2,
											dimnames=list(c("min", "max"), params))
											,filterId=names[i])
							add(wf,rg,...)
						})
					)
			
			
			
		})
##TODO:Either to create a speical logicalGate derived from "filter"
## that just contains the logical vector as indices generated by other algrorithm 
## like flowClust..
## Or we could try to use filterResult and filterResultList from flowCore
## to save the efforts of adding new filter type, but the extra contructor is necessary to 
## convert logical vector to filterResult.
#setMethod("add",
#		signature=c("GatingHierarchy", "logicalGate"),
#		definition=function(wf, action, name,...)
#		{
#			
#			
##			browser()
#			if(missing(name))
#				stop("population name is required!")
#			if(length(action)!=nrow(getData(wf)))
#				stop("the length of logical vector is different from events number in: ",sampleNames(wf))
#			
#			
#			filterObject<-list(type=as.integer(6)
#								,indices=action
#								)	
#			
#			.addGate(wf,filterObject,...)
#		})

#' @importFrom flowCore Rm
#' @export 
#' @rdname add
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingSet",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
			invisible(lapply(envir,function(gh){
#								browser()
								Rm(symbol,gh,subSymbol,...)
							}))
		})
#' @export 
#' @rdname add    
setMethod("Rm",
    signature=c(symbol="character",
        envir="GatingSetList",
        subSymbol="character"),
    definition=function(symbol, envir, subSymbol, ...)
    {
      selectMethod("Rm"
          ,signature = c(symbol="character", envir="GatingSet", subSymbol="character"))(symbol, envir, subSymbol, ...)
    })
    

#' @export 
#' @rdname add
setMethod("Rm",
		signature=c(symbol="character",
				envir="GatingHierarchy",
				subSymbol="character"),
		definition=function(symbol, envir, subSymbol, ...)
		{
            ##remove all children nodes as well
			childrenNodes <- getChildren(envir,symbol)
            #use path instead of unqiue name since the prefix of unique name
            #will change during deletion
			lapply(childrenNodes,function(child)Rm(child,envir))
            
			.Call("R_removeNode",envir@pointer,sampleNames(envir), symbol)
		})


    